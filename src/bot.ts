import { config } from "dotenv";
import TelegramBot from "node-telegram-bot-api";
import db from "./firebase"; 
import {
  Account,
  Aptos,
  Ed25519PrivateKey,
  type InputEntryFunctionData,
  Network,
  PrivateKey,
  PrivateKeyVariants,
  AccountAddress, AptosConfig, NetworkToNetworkName
} from "@aptos-labs/ts-sdk";

config();

const TOKEN = process.env.TELEGRAM_BOT_TOKEN as string;
if (!TOKEN) throw new Error("Thi·∫øu TELEGRAM_BOT_TOKEN trong file .env");

const bot = new TelegramBot(TOKEN, { polling: true });
interface UserData {
  id: number;
  username: string;
  key: string | null;
  wallet: string | null;
  ai_agent: boolean | null;
  ai_agent_config: {
    name: string | null;
    indicators: string[] | null;
    ai_model: string | null;
    timeframe: string | null;
  } | null;
  timestamp: number;
}

const userIndicatorSelections: Record<string, Record<string, boolean>> = {};
const indicators: string[] = [
  "Moving Average (MA)", "Relative Strength Index (RSI)", "MACD",
  "Bollinger Bands", "Stochastic Oscillator", "Fibonacci Retracement",
  "Ichimoku Cloud", "Parabolic SAR", "Volume Profile", "ATR"
];
const generateIndicatorKeyboard = (chatId: string) => {
  if (!userIndicatorSelections[chatId]) {
    userIndicatorSelections[chatId] = {};
  }

  const inlineKeyboard = indicators.map((indicator) => [
    {
      text: `${userIndicatorSelections[chatId][indicator] ? "‚úÖ " : ""}${indicator}`,
      callback_data: `toggle_indicator_${indicator}`,
    },
  ]);

  inlineKeyboard.push([{ text: "üëâ X√°c nh·∫≠n", callback_data: "confirm_indicators" }]);

  return { reply_markup: { inline_keyboard: inlineKeyboard } };
};
const showIndicatorSelection = (chatId: string) => {
  bot.sendMessage(chatId, "üìä H√£y ch·ªçn t·ªëi ƒëa 3 ch·ªâ b√°o:", generateIndicatorKeyboard(chatId));
};

// H√†m hi·ªÉn th·ªã menu ch·ªçn m√¥ h√¨nh AI
const showAIModelSelection = (chatId: string) => {
  const aiModels = ["ChatGPT", "Grok AI", "Gemini", "DeepSeek"];
  const inlineKeyboard = aiModels.map((model) => [
    { text: model, callback_data: `select_ai_model_${model}` },
  ]);

  bot.sendMessage(chatId, "ü§ñ H√£y ch·ªçn m√¥ h√¨nh AI:", {
    reply_markup: { inline_keyboard: inlineKeyboard },
  });
};

// H√†m hi·ªÉn th·ªã menu ch·ªçn khung th·ªùi gian
const showTimeframeSelection = (chatId: string) => {
  const timeframes = ["5m", "15m", "30m", "1h", "4h", "1d"];
  const inlineKeyboard = timeframes.map((timeframe) => [
    { text: timeframe, callback_data: `select_timeframe_${timeframe}` },
  ]);

  bot.sendMessage(chatId, "‚è≥ H√£y ch·ªçn khung th·ªùi gian:", {
    reply_markup: { inline_keyboard: inlineKeyboard },
  });
};


bot.onText(/\/start/, async (msg) => {
  const chatId = msg.chat.id;
  const userName = msg.from?.username || "No Username";

  const userRef = db.ref(`users/${chatId}`);
  const snapshot = await userRef.once("value");
  const userData = snapshot.val();

  if (!userData || !userData.ai_agent) {
    await userRef.set({
      id: chatId,
      username: userName,
      key: null,
      wallet: null,
      ai_agent: false,
      ai_agent_config: null,
      timestamp: Date.now(),
    });

    bot.sendMessage(chatId, "Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi bot c·ªßa t√¥i. S·ª≠ d·ª•ng /create_aiagent ƒë·ªÉ b·∫Øt ƒë·∫ßu.");
  } else {
    bot.sendMessage(chatId, "Welcome back, master!");
  }
});

bot.onText(/\/create_aiagent/, async (msg) => {
  const chatId = msg.chat.id;

  const userRef = db.ref(`users/${chatId}`);
  const snapshot = await userRef.once("value");
  const userData = snapshot.val() as UserData | null;

  if (!userData) {
    bot.sendMessage(chatId, "‚ö†Ô∏è B·∫°n ch∆∞a t·ª´ng s·ª≠ d·ª•ng bot. H√£y nh·∫≠p /start tr∆∞·ªõc.");
    return;
  }

  if (!userData.ai_agent) {
    const options = {
      reply_markup: {
        inline_keyboard: [
          [{ text: "D√πng AI agent m·∫∑c ƒë·ªãnh", callback_data: "default_ai" }],
          [{ text: "T·∫°o AI agent", callback_data: "custom_ai" }],
        ],
      },
    };

    bot.sendMessage(chatId, "Ch·ªçn m·ªôt t√πy ch·ªçn:", options);
  } else {
    bot.sendMessage(chatId, "B·∫°n ƒë√£ c√≥ AI Agent r·ªìi, kh√¥ng th·ªÉ t·∫°o th√™m.");
  }
});
// L·∫Øng nghe callback query
bot.on("callback_query", async (query) => {
  try {
    const chatId: string = query.message?.chat.id.toString() || "";
    const messageId: number | undefined = query.message?.message_id;
    const userRef = db.ref(`users/${chatId}`);

    if (!chatId || !messageId) return;

    if (query.data === "default_ai") {
      await bot.editMessageReplyMarkup({ inline_keyboard: [] }, { chat_id: chatId, message_id: messageId });
      await bot.sendMessage(chatId, "üîß Vui l√≤ng nh·∫≠p t√™n cho AI Agent c·ªßa b·∫°n:");

      bot.once("message", async (msg) => {
        if (msg.chat.id.toString() === chatId) {
          const aiAgentName: string = msg.text!;
          const acc = Account.generate(); // T·∫°o v√≠

          await userRef.update({
            ai_agent: true,
            ai_agent_config: {
              name: aiAgentName,
              indicators: null,
              ai_model: null,
              timeframe: null,
            },
            key: acc.privateKey.toString(),
            wallet: acc.accountAddress.toString(),
          });

          const walletInfo = `üéâ AI Agent *${aiAgentName}* ƒë√£ ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng v·ªõi c·∫•u h√¨nh m·∫∑c ƒë·ªãnh!\n\n`
            + `üîë *V√≠ c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c t·∫°o!*\n`
            + `üìå *ƒê·ªãa ch·ªâ v√≠:* \`${acc.accountAddress.toString()}\`\n`
            + `üîí *Private Key:* \`${acc.privateKey.toString()}\`\n\n`
            + `üö® *L∆∞u √Ω:* H√£y sao l∆∞u private key c·ªßa b·∫°n, kh√¥ng chia s·∫ª cho b·∫•t k·ª≥ ai!`;

          await bot.sendMessage(chatId, walletInfo, { parse_mode: "Markdown" });
        }
      });

    } else if (query.data === "custom_ai") {
      await bot.editMessageReplyMarkup({ inline_keyboard: [] }, { chat_id: chatId, message_id: messageId });
      await bot.sendMessage(chatId, "üîß Vui l√≤ng nh·∫≠p t√™n cho AI Agent c·ªßa b·∫°n:");

      bot.once("message", async (msg) => {
        if (msg.chat.id.toString() === chatId) {
          const aiAgentName: string = msg.text!;

          await userRef.update({
            ai_agent: true,
            ai_agent_config: {
              name: aiAgentName,
              indicators: [],
              ai_model: null,
              timeframe: null,
            },
          });

          await bot.sendMessage(chatId, `üéâ AI Agent *${aiAgentName}* ƒë√£ ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng. B√¢y gi·ªù h√£y c·∫•u h√¨nh n√≥.`, { parse_mode: "Markdown" });

          // Hi·ªÉn th·ªã danh s√°ch ch·ªçn ch·ªâ b√°o
          showIndicatorSelection(chatId);
        }
      });
    } else if (query.data?.startsWith("toggle_indicator_")) {
      const indicator: string = query.data.replace("toggle_indicator_", "");

      if (!userIndicatorSelections[chatId]) {
        userIndicatorSelections[chatId] = {};
      }

      const selectedCount = Object.values(userIndicatorSelections[chatId]).filter(Boolean).length;

      if (userIndicatorSelections[chatId][indicator]) {
        userIndicatorSelections[chatId][indicator] = false;
      } else {
        if (selectedCount >= 3) {
          bot.answerCallbackQuery(query.id, { text: "‚ùå B·∫°n ch·ªâ ƒë∆∞·ª£c ch·ªçn t·ªëi ƒëa 3 ch·ªâ b√°o!", show_alert: true });
          return;
        }
        userIndicatorSelections[chatId][indicator] = true;
      }

      bot.editMessageReplyMarkup(generateIndicatorKeyboard(chatId).reply_markup, {
        chat_id: chatId,
        message_id: query.message?.message_id!,
      });

    } else if (query.data === "confirm_indicators") {
      const selectedIndicators = Object.keys(userIndicatorSelections[chatId]).filter(
        (indicator) => userIndicatorSelections[chatId][indicator]
      );

      if (selectedIndicators.length === 0) {
        bot.answerCallbackQuery(query.id, { text: "‚ùå B·∫°n c·∫ßn ch·ªçn √≠t nh·∫•t 1 ch·ªâ b√°o!", show_alert: true });
        return;
      }

      const snapshot = await userRef.once("value");
      const userData = snapshot.val() as UserData;
      const updatedConfig = {
        ...userData.ai_agent_config,
        indicators: selectedIndicators,
      };

      await userRef.update({ ai_agent_config: updatedConfig });

      await bot.deleteMessage(chatId, query.message?.message_id!);
      await bot.sendMessage(chatId, `‚úÖ You have selected: ${selectedIndicators.join(", ")}`);
      delete userIndicatorSelections[chatId];
      showAIModelSelection(chatId);

    } else if (query.data?.startsWith("select_ai_model_")) {
      const selectedModel = query.data.replace("select_ai_model_", "");

      const snapshot = await userRef.once("value");
      const userData = snapshot.val() as UserData;
      const updatedConfig = {
        ...userData.ai_agent_config,
        ai_model: selectedModel,
      };

      await userRef.update({ ai_agent_config: updatedConfig });

      await bot.deleteMessage(chatId, query.message?.message_id!);
      await bot.sendMessage(chatId, `‚úÖ You have selected m√¥ h√¨nh AI: ${selectedModel}`);

      showTimeframeSelection(chatId);

    } else if (query.data?.startsWith("select_timeframe_")) {
      const selectedTimeframe = query.data.replace("select_timeframe_", "");

      const snapshot = await userRef.once("value");
      const userData = snapshot.val() as UserData;
      const updatedConfig = {
        ...userData.ai_agent_config,
        timeframe: selectedTimeframe,
      };

      await userRef.update({ ai_agent_config: updatedConfig });

      await bot.deleteMessage(chatId, query.message?.message_id!);
      await bot.sendMessage(chatId, `‚úÖ You have selected khung th·ªùi gian: ${selectedTimeframe}`);

      // C√≥ th·ªÉ th·ª±c hi·ªán c√°c h√†nh ƒë·ªông ti·∫øp theo ·ªü ƒë√¢y n·∫øu c·∫ßn
    }

    bot.answerCallbackQuery(query.id);
  } catch (error) {
    console.error("L·ªói:", error);
  }
});




// Logging middleware
// H√†m log chi ti·∫øt ra console
function logMessage(message: string) {
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}] ${message}`);
}

// Log l·ªói polling chi ti·∫øt
bot.on("polling_error", (error) => {
  logMessage(`üö® L·ªñI POLLING: ${error.message}`);
});

// Log khi bot kh·ªüi ƒë·ªông
logMessage("üöÄ Bot ƒëang ch·∫°y...");

// Log khi nh·∫≠n tin nh·∫Øn
bot.on("message", (msg) => {
  logMessage(`üì© Tin nh·∫Øn t·ª´ [ID: ${msg.chat.id} - USER: ${msg.from?.username || "N/A"}]: ${msg.text}`);
});

// Log khi c√≥ callback t·ª´ n√∫t b·∫•m
bot.on("callback_query", (query) => {
  logMessage(`üîò Callback t·ª´ [ID: ${query.message?.chat.id}]: ${query.data}`);
});

